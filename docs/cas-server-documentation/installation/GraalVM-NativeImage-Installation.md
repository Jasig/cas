---
layout: default
title: CAS - GraalVM Native Image Installation
category: Installation
---
{% include variables.html %}

# GraalVM Native Image Installation

[GraalVM Native Images](https://www.graalvm.org/native-image/) are standalone executables that can be generated by 
processing compiled Java applications ahead-of-time. Native Images generally have a smaller memory footprint and start faster than their JVM counterparts.

A CAS server installation and deployment process can be tuned to build and run as a GraalVM native image under a dedicated `native` profile. 
Compared to the Java Virtual Machine, CAS server native images can run with a smaller memory footprint and with much faster startup times. 
A CAS GraalVM Native Image is a complete, platform-specific executable. You do not need to ship a Java Virtual Machine in order to 
run a CAS native image. It requires and uses ahead-of-time (AOT) processing in order to 
create an executable. This ahead-of-time processing involves statically analyzing CAS application code from its main entry point.

<div class="alert alert-warning">:warning: <strong>Usage Warning!</strong><p>
This capability is a work in progress, requires a lot of trial and error and is highly experimental at this point. We encourage you to start 
to experiment and test your CAS deployment with this feature and report feedback.</p></div>

There are some key differences between native and JVM-based CAS deployments. The main differences are:

- Static analysis of the CAS server is performed at build-time from the main entry point.
- Code that cannot be reached when the native image is created will be removed and won’t be part of the executable.
- GraalVM is not directly aware of dynamic elements in CAS code and must be told about reflection, resources, serialization, and dynamic proxies.
- The CAS server application classpath is fixed at build time and cannot change.
- There is no lazy class loading and everything shipped in the final executable will be loaded in memory on startup.

During the AOT processing phase, the CAS web application is started up to the point that *bean definitions* 
are available. *Bean instances* are NOT created during the AOT processing phase. 

The AOT process, integrated directly into the CAS build, will typically generate:

- Java source code under `build/generated/aotSources`
- Bytecode (for dynamic proxies etc) under `build/generated/aotClasses`
- GraalVM JSON hint files
  - Resource hints (`resource-config.json`)
  - Reflection hints (`reflect-config.json`)
  - Serialization hints (`serialization-config.json`)
  - Java Proxy Hints (`proxy-config.json`)
  - JNI Hints (`jni-config.json`)

During Spring AOT processing CAS is started up to the point that bean definitions are available. 
Bean instances are not created during the AOT processing phase.

Note that Hint files that are put under `src/main/resources/META-INF/native-image` are automatically picked up by GraalVM native image tool.
Generated hint files can typicallt be found in `build/generated/aotResources`.

## System Requirements

A GraalVM distribution compatible with [CAS requirements](../planning/Installation-Requirements.html) must be present on the build machine.
Presently and at a minimum, you will need to have GraalVM installed with 
the [native image tool](https://www.graalvm.org/latest/reference-manual/native-image/) in place.
     
Needless to say, the ability to work with GraalVM native image is and will only be available in CAS deployments
that run with an [embedded server container](../installation/Configuring-Servlet-Container-Embedded.html) that ships with CAS directly.
When building a CAS GraalVM native image, an embedded server container will be automatically provided.

## Installation

The ability to build GraalVM native images is built directly into the CAS installation process. The installation script
can be downloaded and prepped using the [CAS Initializr](../installation/WAR-Overlay-Initializr.html). The produced project will
contain a `README` file with instructions on how to build and run CAS native images.

<div class="alert alert-info">:information_source: <strong>Build Time</strong><p>
Building CAS GraalVM native images can be quite resource intensive and time consuming. Depending on the number of modules
included in the build, CAS configuration options and the horsepower of the build machine, the build time can vary greatly
and typically is in the neighborhood of <code>5~15</code> minutes and perhaps longer.</p></div>

Since in AOT and native mode, configuration is being processed and the context is being optimised at build time,
any properties that would influence bean creation (such as the ones used within the bootstrap context) should be set
to the same values at build time and runtime to avoid unexpected behaviour. While building a CAS deployment that contains 
the Spring Cloud Config Client, you must make sure that the configuration data source that it connects to is available at build time. 
For example, if you retrieve configuration data from Spring Cloud Config Server, make sure you have its 
instance running and available at the port indicated in the Config Client setup.

## Known Limitations

CAS GraalVM native images are an evolving technology. Not all libraries used by CAS and not all modules offered by CAS
provide support for native images. Additionally, the following scenarios are unsupported or do require a lot of finesse
and maneuvering to function:
         
- All capabilities and features that load, parse and execute Groovy scripts, or load dynamic code constructs.
- Libraries and dependencies written in Groovy or other dynamic languages will be extremely challenging to support.
- All capabilities and features that load CAS configuration properties from external sources that are backed by Spring Cloud.
- Refresh scope and dynamically refreshing the application context is not supported with CAS native images.

If you find a library which doesn’t work with GraalVM, please discuss that issue
on the [reachability metadata project](https://github.com/oracle/graalvm-reachability-metadata).

Note while the startup time is orders of magnitude faster than on the traditional JVM, 
the actual latency and throughput may be worse on the native image - there is no JIT compiler that optimizes 
code execution paths in runtime. Ideally, you should run performance tests to find out how CAS behaves 
as a native image vs a traditional JVM application.
