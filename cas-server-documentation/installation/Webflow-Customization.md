---
layout: default
title: CAS - Web Flow Customization
---


# Webflow Customization
CAS uses [Spring Web Flow](projects.spring.io/spring-webflow) to do "script" processing of login and logout protocols. 
Spring Web Flow builds on Spring MVC and allows implementing the "flows" of a web application. A flow encapsulates a sequence 
of steps that guide a user through the execution of some business task. It spans multiple HTTP requests, has state, deals with
 transactional data, is reusable, and may be dynamic and long-running in nature. Each flow may contain among many other settings the following major elements:

- Actions: components that describe an executable task and return back a result
- Transitions: Routing the flow from one state to another; Transitions may be global to the entire flow.
- Views: Components that describe the presentation layer displayed back to the client
- Decisions: Components that conditionally route to other areas of flow and can make logical decisions

Spring Web Flow presents CAS with a pluggable architecture where custom actions, views and decisions may be injected into the 
flow to account for additional use cases and processes. Note that to customize the weblow, one must possess a reasonable level
of understanding of the webflow's internals and injection policies. The intention of this document is not to describe Spring Web Flow, 
but merely to demonstrate how the framework is used by CAS to carry out various aspects of the protocol and business logic execution.

## Webflow Sessions

### Client-side Sessions
CAS provides a facility for storing flow execution state on the client in Spring Webflow. Flow state is stored as an encoded byte 
stream in the flow execution identifier provided to the client when rendering a view. 

By default, the conversational state of Spring Webflow is managed inside the application session, which can time out due to inactivity 
and must be cleared upon the termination of flow. Rather than storing this state inside the session, CAS automatically attempts to store 
and keep track of this state on the client in an encrypted form to remove the need for session cleanup, termination and replication.

Default encryption strategy controlled via the settings defined in the `application.properties` file:

```properties
# The encryption secret key. Must be 16 characters long.
# webflow.encryption.key=

# The signing secret key. By default, must be a octet string of size 512.
# webflow.signing.key=

# The algorithm used for secret keys
# webflow.secretkey.alg=AES
```


In the event that keys are not generated by the deployer, CAS will attempt to auto-generate keys and will output
the result for each respected key. The deployer MUST attempt to copy the generated keys over to the appropriate
settings in `application.properties`, specially when running a multi-node CAS deployment. Failure to do so will prevent CAS
to appropriate decrypt and encrypt the webflow state and will prevent successful single sign-on.

<div class="alert alert-warning"><strong>Usage Warning!</strong><p>
While the above settings are all optional, it is recommended that you provide your own configuration and settings for encrypting and 
transcoding of the web session state.</p></div>

### Server-side Sessions

In the event that you wish to use server-side session storage for managing the webflow session, you will need to adjust
the following properties:

```properties
# webflow.session.storage=true
# webflow.session.lock.timeout=30
# webflow.session.max.conversations=5
# webflow.session.compress=false
```

Doing so will likely require you to also enable sticky sessions and/or session replication in a clustered deployment of CAS.


## Webflow Autoconfiguration

Most CAS modules, when declared as a dependency, attempt to autoconfigure the CAS webflow to suit their needs.
This practically means thst the CAS adopter would no longer have to manually massage the CAS webflow configuration,
and the module automatically takes care of all required changes. While this is the default behavior, it is possible that 
you may want to manually handle all such changes. For doing so, you will need to disable the CAS autoconfiguration
of the webflow:

```properties
# webflow.autoconfigure=true
```

## Required Service for Authentication
By default, CAS will present a generic success page if the initial authentication request does not identify
the target application. In some cases, the ability to login to CAS without logging
in to a particular service may be considered a misfeature because in practice, too few users and institutions
are prepared to understand, brand, and support what is at best a fringe use case of logging in to CAS for the
sake of establishing an SSO session without logging in to any CAS-reliant service.

As such, CAS optionally allows adopters to not bother to prompt for credentials when no target application is presented
and instead presents a message when users visit CAS directly without specifying a service.

This behavior is controlled via `application.properties`:

```properties
# Indicates whether an SSO session can be created if no service is present.
# create.sso.missing.service=false
```

## Acceptable Usage Policy
CAS presents the ability to allow the user to accept the usage policy before moving on to the application. 
See [this guide](Webflow-Customization-AUP.html) for more info.

## Customizing authentication exceptions
By default CAS is configured to recognize and handle 10 exceptions that are subclasses of `GeneralSecurityException` or
`PreventedException` in the web flow during authentication transactions processing. Handling is defined by a component called
`AuthenticationExceptionHandler` that has a pre-configured map of these default exceptions which is able to deduce from it a next webflow
event when CAS server catches and passes one of these exceptions to it. The event returned determines the next transition to a state and in most cases that state is the login view. The trick here is that each of those exceptions have the specific message bundle mapping in `messages.properties` like so:

  ```properties
  # Authentication failure messages
  authenticationFailure.AccountDisabledException=This account has been disabled.
  authenticationFailure.AccountLockedException=This account has been locked.
  authenticationFailure.CredentialExpiredException=Your password has expired.
  authenticationFailure.InvalidLoginLocationException=You cannot login from this workstation.
  authenticationFailure.InvalidLoginTimeException=Your account is forbidden to login at this time.
  authenticationFailure.AccountNotFoundException=Invalid credentials.
  authenticationFailure.FailedLoginException=Invalid credentials.
  authenticationFailure.UnauthorizedServiceForPrincipalException=Service access denied due to missing privileges.
  authenticationFailure.UNKNOWN=Invalid credentials.
  ```
  
  so that a specific message could be presented to end users on the login form. Any un-recognized or un-mapped exceptions of type
  `GeneralSecurityException`, `PreventedException` or `AbstractTicketException` presented to `AuthenticationExceptionHandler` results in  the `UNKNOWN` mapping with a generic `Invalid credentials.` message.

  Suppose that there is a need for a custom authentication handler that throws a custom `GeneralSecurityException` with a very specific
  message in this case presented to UI (suppose that the exception type thrown is `com.mycompany.MyAuthenticationException`). To achieve
  this customization, one would need to do the following:

   1. Define the fully qualified name of the exception class in `cas.properties` (comma-separated class names in case of multiple
    mappings):

   ```properties
   cas.custom.authentication.exceptions=com.mycompany.MyAuthenticationException
   ```
   2. Define custom message mapping in `messages.properties` (or the variant for the locale in question):

   ```properties
   authenticationFailure.MyAuthenticationException=Authentication has failed, but it did it my way!!!
   ```


